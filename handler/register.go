// Code generated by "grpc-kit-cli/0.3.5".

package handler

import (
	"context"
	"fmt"
	corev3 "github.com/envoyproxy/go-control-plane/envoy/config/core/v3"
	endpointv3 "github.com/envoyproxy/go-control-plane/envoy/config/endpoint/v3"
	endpointservice "github.com/envoyproxy/go-control-plane/envoy/service/endpoint/v3"
	"github.com/envoyproxy/go-control-plane/pkg/cache/types"
	"github.com/envoyproxy/go-control-plane/pkg/cache/v3"
	"github.com/envoyproxy/go-control-plane/pkg/resource/v3"
	pb "github.com/mingqing/xdserver/api/mingqing/xdserver/v1"
	"github.com/mingqing/xdserver/public"
	"google.golang.org/grpc/health"
	"google.golang.org/grpc/health/grpc_health_v1"
)

// Register 用于服务启动前环境准备
func (m *Microservice) Register(ctx context.Context) error {
	pb.RegisterMingqingXdserverServer(m.server.Server(), m)
	grpc_health_v1.RegisterHealthServer(m.server.Server(), health.NewServer())

	// xds
	// 方式一：使用 go-control-plane 服务
	//snapshotCache := cache.NewSnapshotCache(false, cache.IDHash{}, nil)
	//server := xds.NewServer(context.Background(), snapshotCache, nil)
	//endpointservice.RegisterEndpointDiscoveryServiceServer(m.server.Server(), server)

	// 具体服务发现逻辑
	//go testSnapshot(snapshotCache)

	// xds
	// 方式三：使用自定义 gRPC 服务
	endpointservice.RegisterEndpointDiscoveryServiceServer(m.server.Server(), m)

	// 注册服务信息
	mux, err := m.baseCfg.Register(ctx, pb.RegisterMingqingXdserverHandlerFromEndpoint)
	if err != nil {
		return err
	}

	// 注册前端托管静态数据
	if err = m.baseCfg.HTTPHandlerFrontend(mux, public.Assets); err != nil {
		return err
	}

	// 这里添加其他自定义实现
	if err := m.privateHTTPHandle(mux); err != nil {
		return err
	}

	// 注册HTTP网关
	if err := m.server.RegisterGateway(mux); err != nil {
		return err
	}

	// 开启gRPC与HTTP服务
	if err := m.server.StartBackground(); err != nil {
		return err
	}

	return nil
}

func testSnapshot(snapshotCache cache.SnapshotCache) {
	// cla := makeEndpointsForCluster()

	edsEndpoints := make([]types.Resource, 0)
	edsEndpoints = append(edsEndpoints, makeEndpointsForCluster())

	snapshot, err := cache.NewSnapshot("v1", map[resource.Type][]types.Resource{
		resource.EndpointType: edsEndpoints,
	})

	if err != nil {
		fmt.Println("snapshot err: ", err)
		return
	}

	err = snapshotCache.SetSnapshot(context.Background(), "node1", snapshot)
	if err != nil {
		fmt.Println("snapshot cache set err: ", err)
	}
}

type envoyCluster struct {
	name      string
	port      uint32
	endpoints []string
}

func makeEndpointsForCluster() *endpointv3.ClusterLoadAssignment {
	service := envoyCluster{
		name:      "oneops-syncds-v1",
		port:      8000,
		endpoints: []string{"192.168.0.1", "10.5.17.224"},
	}

	fmt.Printf("Updating endpoints for cluster %s: %v\n", service.name, service.endpoints)

	cla := &endpointv3.ClusterLoadAssignment{
		ClusterName: service.name,
		Endpoints:   []*endpointv3.LocalityLbEndpoints{},
	}

	for _, endpoint := range service.endpoints {
		cla.Endpoints = append(cla.Endpoints,
			&endpointv3.LocalityLbEndpoints{
				LbEndpoints: []*endpointv3.LbEndpoint{{
					HostIdentifier: &endpointv3.LbEndpoint_Endpoint{
						Endpoint: &endpointv3.Endpoint{
							Address: &corev3.Address{
								Address: &corev3.Address_SocketAddress{
									SocketAddress: &corev3.SocketAddress{
										Protocol: corev3.SocketAddress_TCP,
										Address:  endpoint,
										PortSpecifier: &corev3.SocketAddress_PortValue{
											PortValue: service.port,
										},
									},
								},
							},
						},
					},
				}},
			},
		)
	}

	return cla
}
